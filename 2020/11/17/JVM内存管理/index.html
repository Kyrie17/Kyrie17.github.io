<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JVM内存管理 | Kyrie17&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JVM">
    <meta name="description" content="写在开篇本文主要介绍了JVM内存管理和垃圾收集器。 垃圾收集概念我们把还被GC Roots引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC的工作就是找到死的对象，回收它们占用的空间。 我们把GC管理的内存称为堆（heap），垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。 对于内存分配请求，实">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存管理">
<meta property="og:url" content="https://kyrie17.github.io/2020/11/17/JVM内存管理/index.html">
<meta property="og:site_name" content="Kyrie17&#39;s Blog">
<meta property="og:description" content="写在开篇本文主要介绍了JVM内存管理和垃圾收集器。 垃圾收集概念我们把还被GC Roots引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC的工作就是找到死的对象，回收它们占用的空间。 我们把GC管理的内存称为堆（heap），垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。 对于内存分配请求，实">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl01.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl02.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl03.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl04.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl05.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl06.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl07.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl08.png">
<meta property="og:image" content="https://kyrie17.github.io/img/jvmncgl09.png">
<meta property="og:updated_time" content="2020-11-17T11:41:50.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM内存管理">
<meta name="twitter:description" content="写在开篇本文主要介绍了JVM内存管理和垃圾收集器。 垃圾收集概念我们把还被GC Roots引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC的工作就是找到死的对象，回收它们占用的空间。 我们把GC管理的内存称为堆（heap），垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。 对于内存分配请求，实">
<meta name="twitter:image" content="https://kyrie17.github.io/img/jvmncgl01.png">
    
        <link rel="alternate" type="application/atom+xml" title="Kyrie17&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/favicon.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Kyrie17</h5>
          <a href="mailto:1130089209@qq.com" title="1130089209@qq.com" class="mail">1130089209@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Kyrie17" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JVM内存管理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JVM内存管理</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-11-17T11:37:33.000Z" itemprop="datePublished" class="page-time">
  2020-11-17
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java乐园/">Java乐园</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#写在开篇"><span class="post-toc-number">1.</span> <span class="post-toc-text">写在开篇</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#垃圾收集概念"><span class="post-toc-number">2.</span> <span class="post-toc-text">垃圾收集概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾收集器的理想特征"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">垃圾收集器的理想特征</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设计上的权衡"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">设计上的权衡</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#性能指标"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">性能指标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分代收集介绍"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">分代收集介绍</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JVM中的垃圾收集器"><span class="post-toc-number">3.</span> <span class="post-toc-text">JVM中的垃圾收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HotSpot分代"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">HotSpot分代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾回收类型"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">垃圾回收类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存分配"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">内存分配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#指针碰撞"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">指针碰撞</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#TLABs"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">TLABs</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#串行收集器"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">串行收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在年轻代中使用串行收集器"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">在年轻代中使用串行收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在老年代中使用串行收集器"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">在老年代中使用串行收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#何时应该使用串行收集器"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">何时应该使用串行收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并行收集器"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">并行收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在年轻代中使用并行收集器"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">在年轻代中使用并行收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在老年代中使用并行收集器"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">在老年代中使用并行收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#何时使用并行收集器"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">何时使用并行收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并行压缩收集器"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">并行压缩收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在年轻代中使用并行压缩收集器"><span class="post-toc-number">3.6.1.</span> <span class="post-toc-text">在年轻代中使用并行压缩收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在老年代中使用并行压缩收集器"><span class="post-toc-number">3.6.2.</span> <span class="post-toc-text">在老年代中使用并行压缩收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#何时使用并行压缩收集器"><span class="post-toc-number">3.6.3.</span> <span class="post-toc-text">何时使用并行压缩收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Concurrent-Mark-Sweep（CMS）收集器"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">Concurrent Mark-Sweep（CMS）收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在年轻代中使用CMS收集器"><span class="post-toc-number">3.7.1.</span> <span class="post-toc-text">在年轻代中使用CMS收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在老年代中使用-CMS-收集器"><span class="post-toc-number">3.7.2.</span> <span class="post-toc-text">在老年代中使用 CMS 收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#何时使用CMS收集器"><span class="post-toc-number">3.7.3.</span> <span class="post-toc-text">何时使用CMS收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#G1"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">G1</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#G1总览"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">G1总览</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#G1内存占用"><span class="post-toc-number">3.9.1.</span> <span class="post-toc-text">G1内存占用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#G1工作流程"><span class="post-toc-number">3.9.2.</span> <span class="post-toc-text">G1工作流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#年轻代收集"><span class="post-toc-number">3.9.2.1.</span> <span class="post-toc-text">年轻代收集</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Old-GC-并发标记周期"><span class="post-toc-number">3.9.2.2.</span> <span class="post-toc-text">Old GC / 并发标记周期</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#混合垃圾回收周期"><span class="post-toc-number">3.9.2.3.</span> <span class="post-toc-text">混合垃圾回收周期</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Full-GC"><span class="post-toc-number">3.9.2.4.</span> <span class="post-toc-text">Full GC</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#小结"><span class="post-toc-number">3.9.2.5.</span> <span class="post-toc-text">小结</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JVM内存管理"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JVM内存管理</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-11-17 19:37:33" datetime="2020-11-17T11:37:33.000Z"  itemprop="datePublished">2020-11-17</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java乐园/">Java乐园</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="写在开篇"><a href="#写在开篇" class="headerlink" title="写在开篇"></a>写在开篇</h2><p>本文主要介绍了JVM内存管理和垃圾收集器。</p>
<h2 id="垃圾收集概念"><a href="#垃圾收集概念" class="headerlink" title="垃圾收集概念"></a>垃圾收集概念</h2><p>我们把还被GC Roots引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC的工作就是找到死的对象，回收它们占用的空间。</p>
<p>我们把GC管理的内存称为堆（heap），垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。</p>
<p>对于内存分配请求，实现的难点在于在堆中找到一块没有被使用的确定大小的内存空间。所以，对于大部分垃圾回收算法来说避免内存碎片化是非常重要的，它将使得空间分配更加高效。</p>
<h3 id="垃圾收集器的理想特征"><a href="#垃圾收集器的理想特征" class="headerlink" title="垃圾收集器的理想特征"></a>垃圾收集器的理想特征</h3><ul>
<li>安全和全面：活的对象一定不能被清理掉，死的对象一定不能在几个回收周期结束后还在内存中。</li>
<li>高效：不能将我们的应用程序挂起太长时间。我们需要在时间、空间、频次上作出权衡。比如，如果堆内存很小，每次垃圾收集就会很快，但是频次会增加。如果堆内存很大，很久才会被填满，但是每一次回收需要的时间很长。</li>
<li>尽量少的内存碎片：每次将垃圾对象释放以后，这些空间可能分布在各个地方，最糟糕的情况就是，内存中到处都是碎片，在给一个大对象分配空间的时候没有内存可用，实际上内存是够的。消除碎片的方式就是压缩。</li>
<li>可扩展性：在多核多线程应用中，内存分配和垃圾回收都不应该成为可扩展性的瓶颈。原文提到的这一点，我的理解是：单线程垃圾回收在多核系统中会浪费CPU资源，如果我理解错误，请指正我。</li>
</ul>
<h3 id="设计上的权衡"><a href="#设计上的权衡" class="headerlink" title="设计上的权衡"></a>设计上的权衡</h3><p>往下看之前，我们需要先分清楚这里的两个概念：并发和并行</p>
<ul>
<li>并行：多个垃圾回收线程同时工作，而不是只有一个垃圾回收线程在工作</li>
<li>并发：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起</li>
</ul>
<p>在设计或选择垃圾回收算法的时候，我们需要作出以下几个权衡：</p>
<ul>
<li>串行 vs 并行<br>串行收集的情况，即使是多核 CPU，也只有一个核心参与收集。使用并行收集器的话，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行可以让收集工作更快，缺点是带来的复杂性和内存碎片问题。</li>
<li>并发 vs Stop-the-world<br>当 stop-the-world 垃圾收集器工作的时候，应用将完全被挂起。与之相对的，并发收集器在大部分工作中都是并发进行的，也许会有少量的 stop-the-world。<br>stop-the-world 垃圾收集器比并发收集器简单很多，因为应用挂起后堆空间不再发生变化，它的缺点是在某些场景下挂起的时间我们是不能接受的（如 web 应用）。<br>相应的，并发收集器能够降低挂起时间，但是也更加复杂，因为在收集的过程中，也会有新的垃圾产生，同时，需要有额外的空间用于在垃圾收集过程中应用程序的继续使用。</li>
<li>压缩 vs 不压缩 vs 复制<br>当垃圾收集器标记出内存中哪些是活的，哪些是垃圾对象后，收集器可以进行压缩，将所有活的对象移到一起，这样新的内存分配就可以在剩余的空间中进行了。经过压缩后，分配新对象的内存空间是非常简单快速的。<br>相对的，不压缩的收集器只会就地释放空间，不会移动存活对象。优点就是快速完成垃圾收集，缺点就是潜在的碎片问题。通常，这种情况下，分配对象空间会比较慢比较复杂，比如为新的一个大对象找到合适的空间。<br>还有一个选择就是复制收集器，将活的对象复制到另一块空间中，优点就是原空间被清空了，这样后续分配对象空间非常迅速，缺点就是需要进行复制操作和占用额外的空间。</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>以下几个是评估垃圾收集器性能的一些指标：</p>
<ul>
<li>吞吐量：应用程序的执行时间占总时间的百分比，当然是越高越好</li>
<li>垃圾收集开销：垃圾收集时间占总时间的百分比（1 - 吞吐量）</li>
<li>停顿时间：垃圾收集过程中导致的应用程序挂起时间</li>
<li>频次：相对于应用程序来说，垃圾收集的频次</li>
<li>空间：垃圾收集占用的内存</li>
<li>及时性：一个对象从成为垃圾到该对象空间再次可用的时间</li>
</ul>
<p>在交互式程序中，通常希望是低延时的，而对于非交互式程序，总运行时间比较重要。实时应用程序既要求每次停顿时间足够短，也要求总的花费在收集的时间足够短。在小型个人计算机和嵌入式系统中，则希望占用更小的空间。</p>
<h3 id="分代收集介绍"><a href="#分代收集介绍" class="headerlink" title="分代收集介绍"></a>分代收集介绍</h3><p>当我们使用分代垃圾收集器时，内存将被分为不同的代(generation)，最常见的就是分为年轻代和老年代。</p>
<p>在不同的分代中，可以根据不同的特点使用不同的算法。分代垃圾收集基于 weak generational hypothesis 假设（通常国人会翻译成 弱分代假设）：</p>
<ul>
<li>大部分对象都是短命的，它们在年轻的时候就会死去</li>
<li>极少老年对象对年轻对象的引用</li>
</ul>
<p>年轻代中的收集是非常频繁的、高效的、快速的，因为年轻代空间中，通常都是小对象，同时有非常多的不再被引用的对象。</p>
<p>那些经历过多次年轻代垃圾收集还存活的对象会晋升到老年代中，老年代的空间更大，而且占用空间增长比较慢。这样，老年代的垃圾收集是不频繁的，但是进行一次垃圾收集需要的时间更长。</p>
<p>对于新生代，需要选择速度比较快的垃圾回收算法，因为新生代的垃圾回收是频繁的。</p>
<p>对于老年代，需要考虑的是空间，因为老年代占用了大部分堆内存，而且针对该部分的垃圾回收算法，需要考虑到这个区域的垃圾密度比较低。</p>
<h2 id="JVM中的垃圾收集器"><a href="#JVM中的垃圾收集器" class="headerlink" title="JVM中的垃圾收集器"></a>JVM中的垃圾收集器</h2><h3 id="HotSpot分代"><a href="#HotSpot分代" class="headerlink" title="HotSpot分代"></a>HotSpot分代</h3><p>在 HotSpot 虚拟机中，内存被组织成三个分代：年轻代、老年代、永久代。</p>
<ul>
<li>大部分对象初始化的时候都是在年轻代中的</li>
<li>老年代存放经过了几次年轻代垃圾收集依然还活着的对象，还有部分大对象因为比较大所以分配的时候直接在老年代分配</li>
<li>永久代，通常也叫 方法区，用于存储已加载类的元数据，以及存储运行时常量池等</li>
</ul>
<h3 id="垃圾回收类型"><a href="#垃圾回收类型" class="headerlink" title="垃圾回收类型"></a>垃圾回收类型</h3><p>当年轻代被填满后，会进行一次年轻代垃圾收集（也叫做minor GC）。</p>
<p>当老年代或永久代被填满了，会触发full GC（也叫做 major GC），full GC 会收集所有区域，先进行年轻代的收集，使用年轻代专用的垃圾回收算法，然后使用老年代的垃圾回收算法回收老年代和永久代。如果算法带有压缩，每个代分别独立地进行压缩。</p>
<p>如果先进行年轻代垃圾收集，会使得老年代不能容纳要晋升上来的对象，这种情况下，不会先进行young gc，所有的收集器都会（除了CMS）直接采用老年代收集算法对整个堆进行收集（CMS收集器比较特殊，因为它不能收集年轻代的垃圾）。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>如果垃圾收集完成后，存在大片连续的内存可用于分配给新对象，这种情况下分配空间是非常简单快速的，只要一个简单的指针碰撞就可以了（bump-the-pointer），每次分配对象空间只要检测一下是否有足够的空间，如果有，指针往前移动N位就分配好空间了，然后就可以初始化这个对象了。</p>
<h4 id="TLABs"><a href="#TLABs" class="headerlink" title="TLABs"></a>TLABs</h4><p>对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot使用了称之为Thread-Local Allocation Buffers(TLABs) 的技术，该技术能改善多线程空间分配的吞吐量。首先，给予每个线程一部分内存作为缓存区，每个线程都在自己的缓存区中进行指针碰撞，这样就不用获取全局锁了。只有当一个线程使用完了它的TLAB，它才需要使用同步来获取一个新的缓冲区。HotSpot使用了多项技术来降低TLAB对于内存的浪费。比如，TLAB的平均大小被限制在Eden区大小的1%之内。TLABs和使用指针碰撞的线性分配结合，使得内存分配非常简单高效，只需要大概10条机器指令就可以完成。</p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>使用串行收集器，年轻代和老年代都使用单线程进行收集（使用一个CPU），收集过程中会stop-the-world。所以当在垃圾收集的时候，应用程序是完全停止的。</p>
<h4 id="在年轻代中使用串行收集器"><a href="#在年轻代中使用串行收集器" class="headerlink" title="在年轻代中使用串行收集器"></a>在年轻代中使用串行收集器</h4><p>下图展示了年轻代中使用串行收集器的流程。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl01.png" alt="jvm内存管理01" title>
                </div>
                <div class="image-caption">jvm内存管理01</div>
            </figure></p>
<p>年轻代分为一个Eden区和两个Survivor区（From区和To区）。年轻代垃圾收集时，将Eden中活着的对象复制到空的Survivor-To区，Survivor-From区的对象分两类，一类是年轻的，也是复制到Survivor-To区，还有一类是老家伙，晋升到老年代中。</p>
<p>如果复制的过程中，发现Survivor-To空间满了，将剩下还没复制到Survivor-To的来自于Eden和Survivor-From区的对象直接晋升到老年代。</p>
<p>年轻代垃圾收集完成后，Eden区和Survivor-From就干净了，此时，将Survivor-From和 Survivor-To交换一下角色。得到下面这个样子：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl02.png" alt="jvm内存管理02" title>
                </div>
                <div class="image-caption">jvm内存管理02</div>
            </figure></p>
<h4 id="在老年代中使用串行收集器"><a href="#在老年代中使用串行收集器" class="headerlink" title="在老年代中使用串行收集器"></a>在老年代中使用串行收集器</h4><p>如果使用串行收集器，在老年代和永久代将通过使用 标记 -&gt; 清除 -&gt; 压缩算法。标记阶段，收集器识别出哪些对象是活的；清除阶段将遍历一下老年代和永久代，识别出哪些是垃圾；然后执行压缩，将活的对象左移到老年代的起始端（永久代类似），这样就留下了右边一片连续可用的空间，后续就可以通过指针碰撞的方式快速分配对象空间。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl03.png" alt="jvm内存管理03" title>
                </div>
                <div class="image-caption">jvm内存管理03</div>
            </figure></p>
<h4 id="何时应该使用串行收集器"><a href="#何时应该使用串行收集器" class="headerlink" title="何时应该使用串行收集器"></a>何时应该使用串行收集器</h4><p>串行收集器适用于运行在client模式下的大部分程序，它们不要求低延时。在现代硬件条件下，串行收集器可以高效管理64M堆内存，并且能将full GC控制在半秒内完成。</p>
<h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>现在大多数Java应用都运行在大内存、多核环境中，并行收集器，也就是大家熟知的<strong>吞吐量收集器</strong>，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。</p>
<h4 id="在年轻代中使用并行收集器"><a href="#在年轻代中使用并行收集器" class="headerlink" title="在年轻代中使用并行收集器"></a>在年轻代中使用并行收集器</h4><p>并行收集器在年轻代中其实就是串行收集器收集算法的并行版本。它仍然使用 stop-the-world 和复制算法，只不过使用了多核的优势并行执行，降低垃圾收集的时间，从而提高吞吐量。下图示意了在年轻代中，串行收集器和并行收集器的区别：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl04.png" alt="jvm内存管理04" title>
                </div>
                <div class="image-caption">jvm内存管理04</div>
            </figure></p>
<h4 id="在老年代中使用并行收集器"><a href="#在老年代中使用并行收集器" class="headerlink" title="在老年代中使用并行收集器"></a>在老年代中使用并行收集器</h4><p>在老年代中，并行收集器使用的是和串行收集器一样的算法：单线程，标记 -&gt; 清除 -&gt; 压缩。</p>
<p>ps：是的，并行收集器只能在年轻代中并行。</p>
<h4 id="何时使用并行收集器"><a href="#何时使用并行收集器" class="headerlink" title="何时使用并行收集器"></a>何时使用并行收集器</h4><p>其适用于多核、不要求低停顿的应用，因为老年代的收集虽然不频繁，但是每次老年代的单线程垃圾收集依然可能会需要很长时间。比如说，它可以应用在批处理、账单计算、科学计算等。</p>
<p>你应该不会想要这个收集器，而是要一个可以对每个代都采用并行收集的并行压缩收集器，下一节将介绍这个。</p>
<h3 id="并行压缩收集器"><a href="#并行压缩收集器" class="headerlink" title="并行压缩收集器"></a>并行压缩收集器</h3><p>并行压缩收集器于J2SE 5.0 update 6引入，和并行收集器的区别在于它在老年代也使用并行收集算法。注意：并行压缩收集器终将会取代并行收集器。</p>
<h4 id="在年轻代中使用并行压缩收集器"><a href="#在年轻代中使用并行压缩收集器" class="headerlink" title="在年轻代中使用并行压缩收集器"></a>在年轻代中使用并行压缩收集器</h4><p>并行压缩收集器在年轻代中使用了和并行收集器一样的算法。即使用 并行、stop-the-world、复制 算法。</p>
<h4 id="在老年代中使用并行压缩收集器"><a href="#在老年代中使用并行压缩收集器" class="headerlink" title="在老年代中使用并行压缩收集器"></a>在老年代中使用并行压缩收集器</h4><p>在老年代和永久代中，其使用 并行、stop-the-world、滑动压缩 算法。</p>
<p>一次收集分三个阶段，首先，将老年代或永久代逻辑上分为固定大小的区块。</p>
<ul>
<li>标记阶段，将GC Roots分给多个垃圾收集线程，每个线程并行地去标记存活的对象，一旦标记一个存活对象，在该对象所在的区块记录这个对象的大小和对象所在的位置</li>
<li>汇总阶段，此阶段针对区块进行。由于之前的垃圾回收影响，老年代和永久代的左侧是 存活对象密集区，对这部分区域直接进行压缩的代价是不值得的，能清理出来的空间有限。所以第一件事就是，检查每个区块的密度，从左边第一个开始，直到找到一个区块满足：对右侧的所有区块进行压缩获得的空间抵得上压缩它们的成本。这个区块左边的区域过于密集，不会有对象移动到这个区域中。然后，计算并保存右侧区域中每个区块被压缩后的新位置首字节地址<br>右侧的区域将被压缩，对于右侧的每个区块，由于每个区块中保存了该区块的存活对象信息，所以很容易计算每个区块的新位置。注意：汇总阶段目前被实现为串行进行，这个阶段修改为并行也是可行的，不过没有在标记阶段和下面的压缩阶段并行那么重要</li>
<li>压缩阶段，在汇总阶段已经完成了每个区块新位置的计算，所以压缩阶段每个回收线程并行将每个区块复制到新位置即可。压缩结束后，就清出来了右侧一大片连续可用的空间</li>
</ul>
<h4 id="何时使用并行压缩收集器"><a href="#何时使用并行压缩收集器" class="headerlink" title="何时使用并行压缩收集器"></a>何时使用并行压缩收集器</h4><p>首先是多核上的并行优势，这个就不重复了。其次，前面的并行收集器对于老年代和永久代使用串行，而并行压缩收集器在这些区域使用并行，能降低停顿时间。</p>
<p>并行压缩收集器不适合运行在大型共享主机上（如SunRays），因为它在收集的时候会独占几个CPU，在这种机器上，可以考虑减少垃圾收集的线程数（通过 –XX:ParallelGCThreads=n），或者就选择其他收集器。</p>
<h3 id="Concurrent-Mark-Sweep（CMS）收集器"><a href="#Concurrent-Mark-Sweep（CMS）收集器" class="headerlink" title="Concurrent Mark-Sweep（CMS）收集器"></a>Concurrent Mark-Sweep（CMS）收集器</h3><p>重头戏CMS登场了，至少对于我这个web开发者来说，目前CMS最常用（使用JDK8的应用一般都切换到G1收集器了）。前面介绍的都是并行收集，这里要介绍并发收集了，也就是垃圾回收线程和应用程序线程同时运行。</p>
<p>对于许多程序来说，吞吐量不如响应时间来得重要。通常年轻代的垃圾收集不会停顿多长时间，但是，老年代垃圾回收，虽然不频繁，但是可能导致长时间的停顿，尤其当堆内存比较大的时候。为了解决这个问题，HotSpot虚拟机提供了CMS收集器，也叫做<strong>低延时收集器</strong>。</p>
<h4 id="在年轻代中使用CMS收集器"><a href="#在年轻代中使用CMS收集器" class="headerlink" title="在年轻代中使用CMS收集器"></a>在年轻代中使用CMS收集器</h4><p>在年轻代中，CMS和并行收集器一样，即：并行、stop-the-world、复制。</p>
<h4 id="在老年代中使用-CMS-收集器"><a href="#在老年代中使用-CMS-收集器" class="headerlink" title="在老年代中使用 CMS 收集器"></a>在老年代中使用 CMS 收集器</h4><p>在老年代的垃圾收集过程中，大部分收集任务是和应用程序<strong>并发</strong>执行的。</p>
<p>CMS收集过程首先是一段小停顿stop-the-world，叫做<strong>初始标记阶段</strong>（initial mark），用于确定GC Roots。然后是<strong>并发标记阶段</strong>（concurrent mark），标记GC Roots可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为<strong>再次标记阶段</strong>（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，<strong>所以会使用多线程并行执行来增加效率</strong>。</p>
<p>再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的<strong>并发清理阶段</strong>（concurrent sweep） 将就地回收垃圾对象所占空间。下图示意了老年代中<strong>串行、标记 -&gt; 清理 -&gt; 压缩收集器</strong>和<strong>CMS收集器</strong>的区别：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl05.png" alt="jvm内存管理05" title>
                </div>
                <div class="image-caption">jvm内存管理05</div>
            </figure></p>
<p>由于部分任务增加了收集器的工作，如遍历并发阶段应用程序修改的对象，所以增加了CMS收集器的负载。对于大部分试图降低停顿时间的收集器来说，这是一种权衡方案。</p>
<p>CMS收集器是<strong>唯一不进行压缩的收集器</strong>，在它释放了垃圾对象占用的空间后，它不会移动存活对象到一边去。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl06.png" alt="jvm内存管理06" title>
                </div>
                <div class="image-caption">jvm内存管理06</div>
            </figure></p>
<p>这将节省垃圾回收的时间，但是由于之后空闲空间不是连续的，所以也就不能使用简单的<strong>指针碰撞</strong>进行对象空间分配了。它需要维护一个<strong>空闲列表</strong>，将所有的空闲区域连接起来，当分配空间时，需要寻找到一个可以容纳该对象的区域。显然，它比使用简单的指针碰撞成本要高。同时它也会加大年轻代垃圾收集的负载，因为年轻代中的对象如果要晋升到老年代中，需要老年代进行空间分配。</p>
<p>另外一个缺点就是，CMS收集器相比其他收集器需要使用更大的堆内存。因为在并发标记阶段，程序还需要执行，所以需要留足够的空间给应用程序。另外，虽然收集器能保证在标记阶段识别出所有的存活对象，但是由于应用程序并发运行，所以刚刚标记的存活对象很可能立马成为垃圾，而且这部分由于已经被标记为<strong>存活对象</strong>，所以只能到下次老年代收集才会被清理，这部分垃圾称为<strong>浮动垃圾</strong>。</p>
<p>最后，由于缺少压缩环节，堆将会出现碎片化问题。为了解决这个问题，CMS 收集器需要追踪统计最常用的对象大小，评估将来的分配需求，可能还需要分割或合并空闲区域。</p>
<p>不像其他垃圾收集器，CMS收集器不能等到老年代满了才开始收集。否则的话，CMS收集器将退化到使用更加耗时的<strong>stop-the-world、标记-清除-压缩</strong>算法。为了避免这个，CMS收集器需要统计之前每次垃圾收集的时间和老年代空间被消耗的速度。另外，如果老年代空间被消耗了<strong>预设占用率</strong>（initiating occupancy），也将会触发一次垃圾收集，这个占用率通过 –XX:CMSInitiatingOccupancyFraction=n 进行设置，n为老年代空间的占用百分比，默认值是68。</p>
<p>总结下来，和并行收集器相比，CMS收集器<strong>降低了老年代收集时的停顿时间</strong>（有时是显著降低），<strong>稍微增加了一些年轻代收集的时间、降低了吞吐量</strong>以及<strong>需要更多的堆内存</strong>。</p>
<h4 id="何时使用CMS收集器"><a href="#何时使用CMS收集器" class="headerlink" title="何时使用CMS收集器"></a>何时使用CMS收集器</h4><p>适用于应用程序要求低停顿，同时能接受在垃圾收集阶段和垃圾收集线程一起共享CPU资源的场景，典型的就是web应用了。</p>
<p>在web应用中，低延时非常重要，所以CMS几乎就是唯一选择，直到后来G1的出现。</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1被设计用来长期取代CMS收集器，和CMS相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1没有CMS的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如6GB及以上）而且还要求有较低的垃圾收集停顿时间（如0.5秒），那么G1是你绝佳的选择，是时候放弃CMS了。</p>
<h3 id="G1总览"><a href="#G1总览" class="headerlink" title="G1总览"></a>G1总览</h3><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p>
<p>而G1将整个堆划分为一个个大小相等的小块（每一块称为一个region），每一块的内存是连续的。和分代算法一样，G1中每个块也会充当Eden、Survivor、Old三种角色，但是它们不是固定的，这使得内存使用更加地灵活。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl07.png" alt="JVM内存管理07" title>
                </div>
                <div class="image-caption">JVM内存管理07</div>
            </figure></p>
<p>执行垃圾收集时，和CMS一样，G1收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1也就知道哪些区块基本上是垃圾，存活对象极少，G1会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么G1被取名为Garbage-First的原因</strong>。</p>
<p>在G1中，目标停顿时间非常非常重要，用-XX:MaxGCPauseMillis=200指定期望的停顿时间。</p>
<p>G1使用了停顿预测模型来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p>
<p>我们要知道G1不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p>
<p><strong>注意</strong>：G1有和应用程序一起运行的<strong>并发</strong>阶段，也有stop-the-world的<strong>并行</strong>阶段。但是，Full GC的时候还是<strong>单线程</strong>运行的，所以我们应该尽量避免发生Full GC，后面我们也会介绍什么时候会触发Full GC。</p>
<h4 id="G1内存占用"><a href="#G1内存占用" class="headerlink" title="G1内存占用"></a>G1内存占用</h4><p>G1比ParallelOld和CMS会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p>
<ul>
<li>Remembered Sets：每个区块都有一个RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块B，区块B的Rset需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上Remembered Sets消耗的内存小于5%</li>
<li>Collection Sets：将要被回收的区块集合。GC时，在这些区块中的对象会被复制到其他区块中，总体上Collection Sets消耗的内存小于1%</li>
</ul>
<h4 id="G1工作流程"><a href="#G1工作流程" class="headerlink" title="G1工作流程"></a>G1工作流程</h4><p>G1收集器主要包括了以下4种操作：</p>
<ol>
<li>年轻代收集</li>
<li>并发收集，和应用线程同时执行</li>
<li>混合式垃圾收集</li>
<li>必要时的 Full GC</li>
</ol>
<h5 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h5><p>首先，我们来看下 G1 的堆结构：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl08.png" alt="jvm内存管理08" title>
                </div>
                <div class="image-caption">jvm内存管理08</div>
            </figure></p>
<p>年轻代中的垃圾收集流程（Young GC）：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/jvmncgl09.png" alt="jvm内存管理09" title>
                </div>
                <div class="image-caption">jvm内存管理09</div>
            </figure></p>
<p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p>
<h5 id="Old-GC-并发标记周期"><a href="#Old-GC-并发标记周期" class="headerlink" title="Old GC / 并发标记周期"></a>Old GC / 并发标记周期</h5><p>接下来是Old GC的流程（含Young GC阶段），其实把Old GC理解为并发周期是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p>
<ul>
<li>初始标记：stop-the-world，它伴随着一次普通的Young GC发生，然后对Survivor区（root region）进行标记，因为该区可能存在对老年代的引用<br>因为Young GC是需要stop-the-world的，所以并发周期直接重用这个阶段，虽然会增加CPU开销，但是停顿时间只是增加了一小部分</li>
<li>扫描根引用区：因为先进行了一次YGC，所以当前年轻代只有Survivor区有存活对象，它被称为根引用区。扫描Survivor到老年代的引用，该阶段必须在下一次Young GC发生前结束<br>这个阶段不能发生年轻代收集，如果中途Eden区真的满了，也要等待这个阶段结束才能进行Young GC</li>
<li>并发标记：寻找整个堆的存活对象，该阶段可以被Young GC中断<br>这个阶段是并发执行的，中间可以发生多次Young GC，Young GC会中断标记过程</li>
<li>重新标记：stop-the-world，完成最后的存活对象标记。使用了比CMS收集器更加高效的snapshot-at-the-beginning(SATB)算法<br>Oracle的资料显示，这个阶段会回收完全空闲的区块</li>
<li>清理：清理阶段真正回收的内存很少</li>
</ul>
<p>到这里，G1的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次stop-the-world的Young GC打断。</p>
<h5 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h5><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p>
<p>下面我们来介绍特殊情况，那就是会导致Full GC的情况，也是我们需要极力避免的：</p>
<ul>
<li>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1并发标记期间，如果在标记结束前，老年代被填满，G1会放弃标记<br>这个时候说明堆需要增加了，或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束，或者就是更早地进行并发周期，默认是整堆内存的45% 被占用就开始进行并发周期</li>
<li>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败<br>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块</li>
<li>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的<br>最简单的就是增加堆大小</li>
<li>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>首先，最好不要把上面的Old GC当做是一次GC来看，而应该当做并发标记周期来理解，虽然它确实会释放出一些内存。</p>
<p>并发标记结束后，G1也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次GC。</p>
<p>我们假设并发标记结束了，那么下次GC的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p>
<p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是45，也就是说当堆空间使用了45%后，G1就会进入并发标记周期。</p>
<p>G1调优的目标是尽量避免出现Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p>
<p>有以下几点我们可以进行调整的方向：</p>
<ul>
<li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li>
<li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li>
<li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认45%）</li>
<li>在混合垃圾回收周期中回收更多的老年代区块</li>
</ul>
<p>G1的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p>
<p>我们通过设置-XX:MaxGCPauseMillis=N来指定停顿时间（单位ms，默认200ms），如果没有达到这个目标，G1会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p>
<p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加Full GC的风险等等。</p>
<p>文章大篇幅整理自：</p>
<ul>
<li><a href="https://www.javadoop.com/" target="_blank" rel="noopener">https://www.javadoop.com/</a> 垃圾收集器相关文章。</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-11-17T11:41:50.197Z" itemprop="dateUpdated">2020-11-17 19:41:50</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://kyrie17.github.io">
            <img src="/img/favicon.jpeg" alt="Kyrie17">
            Kyrie17
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&title=《JVM内存管理》 — Kyrie17's Blog&pic=https://kyrie17.github.io/img/favicon.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&title=《JVM内存管理》 — Kyrie17's Blog&source=You got a dream..You gotta protect it." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://kyrie17.github.io/2020/11/17/JVM内存管理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM内存管理》 — Kyrie17's Blog&url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&via=https://kyrie17.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/11/29/心跳包设计/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">心跳包设计</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/11/16/Java类是如何被加载的/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java类是如何被加载的</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Kyrie17 &copy; 2017 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&title=《JVM内存管理》 — Kyrie17's Blog&pic=https://kyrie17.github.io/img/favicon.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&title=《JVM内存管理》 — Kyrie17's Blog&source=You got a dream..You gotta protect it." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://kyrie17.github.io/2020/11/17/JVM内存管理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM内存管理》 — Kyrie17's Blog&url=https://kyrie17.github.io/2020/11/17/JVM内存管理/&via=https://kyrie17.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://kyrie17.github.io/2020/11/17/JVM内存管理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aQY7jQAgF0L7/pT3blmbsfMAeKfjVqpVUx/W8QEDx8xOv49f6/cnfe872n/1m/vkNCwMD42sZx+U621Ol5v97/dzT38HAwHgB4zrwXR+o9/jkNRWCMgYGBsZJIjjh5WEaAwMDY8LI0768TMXAwMCYFLFJ8L0uNauF7iO1OAYGxhcy8q77///7kfsNDAyMr2IcxVUNuPmxjsHCwMDYzbj3MdWC9i42BgbGGxjVJlpvbCJvwyXtuQ9UDAyMRYw8XD4dXntXm//IcDEwMFYzJs2ve68Q8qdjYGC8h5EEuHnYzfeXAzQGBsZqRj4c1guRk2GLZjMOAwNjKaOaivUGI/JSuZeGYmBgbGXkl5HVnZOOfflFYGBgrGaUN8WhcDKukaeqXSsGBsY3MfLG/SSJnIfRcv2NgYGxjlFtnFWPmCeRzTIYAwNjNWPSJsuL1d7RqzAMDIytjGoZ2QuRdwXuDzMjGBgYSxlJylUNuL2hjd4TC5kjBgbGCkYvgFaL1bz1X04fMTAwXsaYJG3V1tj1ofNvMTAw3sDIRxyqbbXqPWO1/YeBgbGbcRTXE020ZODjAxUDA2M1I1/zsYnqzkm6iYGBsY8xGYy463ogCbiFN42BgbGUMWmE5bwcUz0tBgYGRq/UzK9F8xL3kYCLgYGxlNEb1MiDcjkBxcDAeAEjvwzIC9fqBWf1yhMDA+M9jN6IQ/Kj1YSyei2KgYHxAsYfhmxBz9nNtz4AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
