<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Java反射 | Kyrie17&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content>
    <meta name="description" content="转载自：http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html 概述  反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。  反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进">
<meta property="og:type" content="article">
<meta property="og:title" content="Java反射">
<meta property="og:url" content="https://kyrie17.github.io/2019/04/20/Java反射/index.html">
<meta property="og:site_name" content="Kyrie17&#39;s Blog">
<meta property="og:description" content="转载自：http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html 概述  反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。  反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect1.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect2.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect3.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect4.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect5.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect6.png">
<meta property="og:image" content="https://kyrie17.github.io/img/reflect7.png">
<meta property="og:updated_time" content="2020-11-15T16:38:09.640Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java反射">
<meta name="twitter:description" content="转载自：http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html 概述  反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。  反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进">
<meta name="twitter:image" content="https://kyrie17.github.io/img/reflect1.png">
    
        <link rel="alternate" type="application/atom+xml" title="Kyrie17&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/favicon.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Kyrie17</h5>
          <a href="mailto:1130089209@qq.com" title="1130089209@qq.com" class="mail">1130089209@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Kyrie17" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java反射</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java反射</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-04-20T14:50:04.000Z" itemprop="datePublished" class="page-time">
  2019-04-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java乐园/">Java乐园</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">2.</span> <span class="post-toc-text">Java反射框架提供以下功能：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">3.</span> <span class="post-toc-text">反射的主要用途</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">4.</span> <span class="post-toc-text">一个简单的例子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">而如果要调用某一个方法，则需要经过下面的步骤：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">5.</span> <span class="post-toc-text">反射常用API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">获取反射中的Class对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">通过反射创建类对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#null"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">通过反射获取类属性、方法、构造器</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#null"><span class="post-toc-number">6.</span> <span class="post-toc-text">反射源码解析</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Java反射"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java反射</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-20 22:50:04" datetime="2019-04-20T14:50:04.000Z"  itemprop="datePublished">2019-04-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java乐园/">Java乐园</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>转载自：http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</p>
<h2>概述</h2>
<blockquote>
<p>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p>
</blockquote>
<p>反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。</p>
<p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple = <span class="keyword">new</span> Apple(); <span class="comment">//直接初始化，「正射」</span></span><br><span class="line">apple.setPrice(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面这样子进行类对象的初始化，我们可以理解为「正」。</p>
<p>而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。</p>
<p>这时候，我们使用 JDK 提供的反射 API 进行反射调用：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"com.chenshuyi.reflect.Apple"</span>);</span><br><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br><span class="line">method.invoke(object, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。</p>
<p>所以说什么是反射？</p>
<blockquote>
<p>当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为 Java 并不是动态语言，但是它却又一个非常突出的动态相关的机制，俗称：反射。
Reflection 是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。</p>
</blockquote>
<p>通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。</p>
<p>程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的.</p>
<p>反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<h2>Java反射框架提供以下功能：</h2>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射设置可以调用 private）</li>
<li>在运行时调用人一个对象的方法</li>
</ul>
<h2>反射的主要用途</h2>
<p>很多人都认为反射在实际Java中开发应用中并不广泛，其实不然。
当我们在使用 IDE（如 Eclipse\IDEA）时，当我们输入一个队长或者类并向调用它的属性和方法时，一按 (“.”)点号，编译器就会自动列出她的属性或方法，这里就会用到反射。</p>
<p><strong>反射最重要的用途就是开发各种通用框架。</strong>
很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">class</span>=<span class="string">"org.ScZyhSoft.test.action.SimpleLoginAction"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span>&gt;</span>/shop/shop-index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。</p>
<p>——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。
对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h2>一个简单的例子</h2>
<p>上面提到的示例程序，其完整的程序代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//正常的调用</span></span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setPrice(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"Apple Price:"</span> + apple.getPrice());</span><br><span class="line">        <span class="comment">//使用反射调用</span></span><br><span class="line">        Class clz = Class.forName(<span class="string">"com.chenshuyi.api.Apple"</span>);</span><br><span class="line">        Method setPriceMethod = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        Constructor appleConstructor = clz.getConstructor();</span><br><span class="line">        Object appleObj = appleConstructor.newInstance();</span><br><span class="line">        setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br><span class="line">        Method getPriceMethod = clz.getMethod(<span class="string">"getPrice"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Apple Price:"</span> + getPriceMethod.invoke(appleObj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple Price:<span class="number">5</span></span><br><span class="line">Apple Price:<span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3>从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤：</h3>
<ol>
<li>
<p>获取类的 Class 对象实例
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"com.zhenai.api.Apple"</span>);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>根据 Class 对象实例获取 Constructor 对象
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor appleConstructor = clz.getConstructor();</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>使用 Constructor 对象的 newInstance 方法获取反射类对象
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object appleObj = appleConstructor.newInstance();</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<hr>
<h3>而如果要调用某一个方法，则需要经过下面的步骤：</h3>
<ol>
<li>
<p>获取方法的 Method 对象
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method setPriceMethod = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>利用 invoke 方法调用方法
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。</p>
<p>在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p>
<h2>反射常用API</h2>
<h3>获取反射中的Class对象</h3>
<p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p>
<p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<p>**第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>第二种，使用 .class 方法。</strong></p>
<p>这种方法只适合在编译前就知道操作的 Class。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = String.class;</span><br></pre></td></tr></table></figure></p>
<p><strong>第三种，使用类对象的 getClass() 方法。</strong>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">Class clz = str.getClass();</span><br></pre></td></tr></table></figure></p>
<h3>通过反射创建类对象</h3>
<p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法</p>
<p>第一种：通过 Class 对象的 newInstance() 方法
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Apple apple = (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>第二种：通过 Constructor 对象的 newInstance() 方法
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Apple apple = (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Apple apple = (Apple)constructor.newInstance(<span class="string">"红富士"</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure></p>
<h3>通过反射获取类属性、方法、构造器</h3>
<p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price</span><br></pre></td></tr></table></figure></p>
<p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">price</span><br></pre></td></tr></table></figure></p>
<p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p>
<h2>反射源码解析</h2>
<p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:497)</span><br></pre></td></tr></table></figure></p>
<p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span>.class); </span><br><span class="line">method.invoke(object, <span class="number">4</span>);   <span class="comment">//就是这里的invoke方法</span></span><br></pre></td></tr></table></figure></p>
<p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.chenshuyi.Apple"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p>
<p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p>
<p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p>
<p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect1.png" alt="reflect1" title>
                </div>
                <div class="image-caption">reflect1</div>
            </figure></p>
<p>那么 MethodAccessor 又是什么呢？其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect2.png" alt="reflect2" title>
                </div>
                <div class="image-caption">reflect2</div>
            </figure></p>
<p>从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect3.png" alt="reflect3" title>
                </div>
                <div class="image-caption">reflect3</div>
            </figure></p>
<p>在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p>
<p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect4.png" alt="reflect4" title>
                </div>
                <div class="image-caption">reflect4</div>
            </figure></p>
<p>所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect5.png" alt="reflect5" title>
                </div>
                <div class="image-caption">reflect5</div>
            </figure></p>
<p>进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect6.png" alt="reflect6" title>
                </div>
                <div class="image-caption">reflect6</div>
            </figure></p>
<p>而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p>
<p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Inflation&quot; mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</span><br><span class="line"></span><br><span class="line">Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</span><br><span class="line"></span><br><span class="line">To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</span><br><span class="line"></span><br><span class="line">为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</span><br></pre></td></tr></table></figure></p>
<p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p>
<p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p>
<p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p>
<p><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/reflect7.png" alt="reflect7" title>
                </div>
                <div class="image-caption">reflect7</div>
            </figure></p>
<p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-11-15T16:38:09.640Z" itemprop="dateUpdated">2020-11-16 00:38:09</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://kyrie17.github.io">
            <img src="/img/favicon.jpeg" alt="Kyrie17">
            Kyrie17
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://kyrie17.github.io/2019/04/20/Java反射/&title=《Java反射》 — Kyrie17's Blog&pic=https://kyrie17.github.io/img/favicon.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://kyrie17.github.io/2019/04/20/Java反射/&title=《Java反射》 — Kyrie17's Blog&source=You got a dream..You gotta protect it." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://kyrie17.github.io/2019/04/20/Java反射/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java反射》 — Kyrie17's Blog&url=https://kyrie17.github.io/2019/04/20/Java反射/&via=https://kyrie17.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://kyrie17.github.io/2019/04/20/Java反射/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/10/通配符类型/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">通配符类型</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/04/12/保存对象/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">保存对象</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Kyrie17 &copy; 2017 - 2022</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://kyrie17.github.io/2019/04/20/Java反射/&title=《Java反射》 — Kyrie17's Blog&pic=https://kyrie17.github.io/img/favicon.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://kyrie17.github.io/2019/04/20/Java反射/&title=《Java反射》 — Kyrie17's Blog&source=You got a dream..You gotta protect it." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://kyrie17.github.io/2019/04/20/Java反射/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java反射》 — Kyrie17's Blog&url=https://kyrie17.github.io/2019/04/20/Java反射/&via=https://kyrie17.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://kyrie17.github.io/2019/04/20/Java反射/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKUlEQVR42u3aywrDMAxE0fz/T6fbQrEzM7ILka9XpYTEJwXVelyXvO6v9fvN9/ej691nXTsWDBgwXsu4p0vftPsi5nvQ9wYDBoxzGPPAN/+sXKnfZ36H4fcwYMCAIWyoHkyV58KAAQOGG3CzcKyAYcCAASNLYrPS2/zx7p0X5OIwYMB4IcMt1v/z85b+BgwYMF7FuM3llsb0o+FdWDBgwOjNyBqQ+iFSCdzLGqIwYMBoynBvqofXLOHUYcPfAQYMGO0YWeLqjkpUCmp6yQ8GDBi9GfPgqDcR66mpEnxhwIBxGsNtPbrNRfe4GY6AwIAB4wBGNkKxNkHV/x+G0yIwYMBoyshIbiDe0RJY8MvAgAHjhYysMqcX1NwafmlvMGDAaMRww6h7pHMbCXoSO6wXwoABox3DDXPzm2ad0lVHRhgwYJzAyApn2WEuG/wyhi1gwIDRjqE8Mhvnqm/Xjq4wYMA4kpG1JN3joz6Q8RDuYcCA0ZpRGZJwi25KKNcbojBgwDiBoV+aBb75FvWGxMMOYcCAcQDDrbS7qea+AyIMGDDOYdTHSd2XUhkdgwEDxjmM21zZsIUb0O38GwYMGK0Z9aKbHmr1IKtcbzcGYMCA8XKGW6x3C2F6+F7WpIQBA0ZThh746g3Oyj/AwzkXBgwYMDbkj1l5DgYMGDDcBLIy7KW3S0udWBgwYLRgVEYilFfgJq7ui4ABA0ZvRpY66tvKjonKS4QBA8YBjA+bxCy6ERqKmAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
